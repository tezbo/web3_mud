<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Tiny Web MUD</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5, user-scalable=yes">
  <meta name="theme-color" content="#0a0a0a">
  <!-- Socket.IO Client Library -->
  <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
  <style>
    /* CSS Variables for theming */
    :root {
      --bg-gradient-start: #0a0a0a;
      --bg-gradient-mid: #1a1a1a;
      --bg-gradient-end: #0a0a0a;
      --bg-output: rgba(15, 15, 15, 0.95);
      --text-primary: #e0e0e0;
      --text-secondary: #9ca3af;
      --border-color: #333;
      --scrollbar-track: #1a1a1a;
      --scrollbar-thumb: #444;
      --scrollbar-thumb-hover: #555;
      --input-bg: #1a1a1a;
      --input-border: #333;
      --input-focus-bg: #1f1f1f;
      --topbar-border: #333;
      --command-prompt: #60a5fa;
      --error-message: #f87171;
      --success-message: #34d399;
      --npc-message: #fbbf24;
      --location-name: #a78bfa;
      --item-name: #60a5fa;
      --exits-highlight: #fbbf24;
      --wallet-info: #34d399;
      --cyan-message: #00ffff;
    }

    body.light-mode {
      --bg-gradient-start: #f9fafb;
      --bg-gradient-mid: #f3f4f6;
      --bg-gradient-end: #f9fafb;
      --bg-output: rgba(255, 255, 255, 0.95);
      --text-primary: #1f2937;
      --text-secondary: #6b7280;
      --border-color: #d1d5db;
      --scrollbar-track: #e5e7eb;
      --scrollbar-thumb: #9ca3af;
      --scrollbar-thumb-hover: #6b7280;
      --input-bg: #ffffff;
      --input-border: #d1d5db;
      --input-focus-bg: #f9fafb;
      --topbar-border: #d1d5db;
      --command-prompt: #2563eb;
      --error-message: #dc2626;
      --success-message: #059669;
      --npc-message: #d97706;
      --location-name: #7c3aed;
      --item-name: #2563eb;
      --exits-highlight: #d97706;
      --wallet-info: #059669;
      --cyan-message: #0891b2;
    }
    * {
      box-sizing: border-box;
    }
    body {
      background: linear-gradient(135deg, var(--bg-gradient-start) 0%, var(--bg-gradient-mid) 50%, var(--bg-gradient-end) 100%);
      background-attachment: fixed;
      color: var(--text-primary);
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      height: 100vh;
      overflow: hidden;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }
    .container {
      display: flex;
      flex-direction: column;
      max-width: 900px;
      width: 100%;
      margin: 0 auto;
      padding: clamp(8px, 2vw, 16px);
      flex: 1;
      min-height: 0;
      overflow: hidden;
    }
    .top-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: clamp(12px, 2vw, 16px);
      padding-bottom: clamp(12px, 2vw, 16px);
      border-bottom: 1px solid var(--topbar-border);
      font-size: clamp(12px, 3vw, 14px);
      flex-shrink: 0;
      flex-wrap: wrap;
      gap: 8px;
    }
    .top-bar > div {
      display: flex;
      align-items: center;
      gap: 12px;
      flex-wrap: wrap;
    }
    .top-bar a {
      color: #60a5fa;
      text-decoration: none;
      transition: all 0.3s ease;
      padding: 6px 12px;
      border-radius: 6px;
      font-weight: 500;
    }
    .top-bar a:hover {
      color: #93c5fd;
      text-decoration: none;
      background: rgba(96, 165, 250, 0.1);
    }
    .top-bar strong {
      color: var(--text-primary);
      font-weight: 600;
    }
    /* Light mode adjustments for specific elements */
    body.light-mode .top-bar a {
      color: var(--command-prompt);
    }
    body.light-mode .top-bar a:hover {
      background: rgba(37, 99, 235, 0.1);
    }
    #output {
      flex: 1;
      border: 1px solid var(--border-color);
      border-radius: 8px;
      padding: clamp(12px, 3vw, 16px);
      overflow-y: auto;
      white-space: pre-wrap;
      background: var(--bg-output);
      font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
      font-size: clamp(12px, 3vw, 14px);
      line-height: 1.7;
      word-wrap: break-word;
      -webkit-overflow-scrolling: touch;
    }
    /* Scrollbar styling */
    #output::-webkit-scrollbar {
      width: 8px;
    }
    #output::-webkit-scrollbar-track {
      background: var(--scrollbar-track);
      border-radius: 4px;
    }
    #output::-webkit-scrollbar-thumb {
      background: var(--scrollbar-thumb);
      border-radius: 4px;
    }
    #output::-webkit-scrollbar-thumb:hover {
      background: var(--scrollbar-thumb-hover);
    }
    /* Text styling classes */
    #output .command-prompt {
      color: var(--command-prompt);
      font-weight: 600;
    }
    #output .system-message {
      color: var(--text-secondary);
      font-style: italic;
    }
    #output .error-message {
      color: var(--error-message);
      font-weight: 500;
    }
    #output .success-message {
      color: var(--success-message);
    }
    #output .npc-message {
      color: var(--npc-message);
      font-weight: 500;
    }
    #output .location-name {
      color: var(--location-name);
      font-weight: 600;
      font-size: 15px;
    }
    #output .item-name {
      color: var(--item-name);
      font-weight: 500;
    }
    #output .exits-highlight {
      color: var(--exits-highlight);
      font-weight: bold;
    }
    #output .wallet-info {
      color: var(--wallet-info);
      font-weight: 500;
    }
    #output .cyan-message {
      color: var(--cyan-message);
      font-weight: 500;
    }
    /* Spacing between messages */
    #output > * {
      margin-bottom: 8px;
    }
    .input-row {
      display: flex;
      margin-top: 12px;
      gap: 10px;
      flex-shrink: 0;
    }
    #command {
      flex: 1;
      padding: clamp(12px, 3vw, 14px);
      border-radius: 8px;
      border: 1px solid var(--input-border);
      background: var(--input-bg);
      color: var(--text-primary);
      font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
      font-size: 16px; /* Prevents zoom on iOS */
      transition: all 0.3s ease;
      -webkit-appearance: none;
      appearance: none;
    }
    #command:focus {
      outline: none;
      border-color: var(--command-prompt);
      box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
      background: var(--input-focus-bg);
    }
    button {
      padding: clamp(12px, 3vw, 14px) clamp(18px, 4vw, 20px);
      border-radius: 8px;
      border: none;
      background: #3b82f6;
      color: #fff;
      font-size: clamp(13px, 3vw, 14px);
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      min-height: 44px; /* Touch-friendly */
      white-space: nowrap;
    }
    button:hover:not(:disabled) {
      background: #2563eb;
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
    }
    button:active:not(:disabled) {
      transform: translateY(0);
    }
    button:disabled {
      opacity: 0.6;
      cursor: default;
    }
    /* Mobile optimizations */
    @media (max-width: 480px) {
      .container {
        padding: 8px;
      }
      .top-bar {
        flex-direction: column;
        align-items: flex-start;
      }
      .top-bar > div {
        width: 100%;
        justify-content: space-between;
      }
      #output {
        padding: 12px;
        font-size: 12px;
      }
      #command {
        padding: 14px;
      }
      button {
        padding: 14px 16px;
        min-width: 70px;
      }
    }
    /* Touch-friendly improvements */
    @media (hover: none) and (pointer: coarse) {
      button {
        min-height: 48px;
      }
      .top-bar a {
        min-height: 44px;
        display: inline-flex;
        align-items: center;
      }
    }
    /* Typing indicator */
    .typing-indicator {
      color: var(--text-secondary);
      font-style: italic;
      opacity: 0.7;
    }
    /* Meta command messages */
    .meta-message {
      color: var(--text-secondary);
      font-style: italic;
      font-size: 0.9em;
    }
    .typing-indicator::after {
      content: '...';
      animation: dots 1.5s steps(4, end) infinite;
    }
    @keyframes dots {
      0%, 20% { content: '.'; }
      40% { content: '..'; }
      60%, 100% { content: '...'; }
    }
  </style>
</head>
<body{% if onboarding %} data-onboarding="true"{% endif %}{% if color_settings %} data-color-settings="{{ color_settings | tojson }}"{% endif %}>
  <div class="container">
    <div class="top-bar">
      <div>
        {% if session.username %}
          Logged in as <strong>{{ session.username }}</strong>
        {% endif %}
      </div>
      <div>
        <a href="{{ url_for('guide') }}" style="margin-right: 15px;">ðŸ“œ Guide</a>
        <a href="{{ url_for('logout') }}">Log out</a>
      </div>
    </div>
    <div id="output">{% if log and log|length > 0 and ('[PAUSE:' in (log[0]|string) or '[ELLIPSIS:' in (log[0]|string)) %}{{ log[0] | safe }}{% else %}{{ "\n".join(log) | safe }}{% endif %}</div>
    <div class="input-row">
      <input id="command" type="text" placeholder="Type a command (try: look, go north, inventory, help)" autocomplete="off">
      <button id="sendBtn">Send</button>
    </div>
  </div>

  <script>
    const outputEl = document.getElementById("output");
    const commandEl = document.getElementById("command");
    const sendBtn = document.getElementById("sendBtn");

    // Load user color preferences from data attribute or update from command responses
    let userColorSettings = {};
    function updateColorSettings(settings) {
      if (settings && typeof settings === 'object') {
        userColorSettings = settings;
        // Update data attribute
        document.body.setAttribute('data-color-settings', JSON.stringify(settings));
      }
    }
    
    // Initialize from page load
    try {
      const colorSettingsAttr = document.body.getAttribute('data-color-settings');
      if (colorSettingsAttr) {
        updateColorSettings(JSON.parse(colorSettingsAttr));
      }
    } catch (e) {
      console.warn('Failed to parse color settings:', e);
    }

    // Color hex mapping
    const COLOR_HEX_MAP = {
      "black": "#000000", "white": "#ffffff", "gray": "#808080", "grey": "#808080",
      "lightgray": "#d3d3d3", "lightgrey": "#d3d3d3", "darkgray": "#a9a9a9", "darkgrey": "#a9a9a9",
      "red": "#ff0000", "darkred": "#8b0000", "lightred": "#ff6b6b", "pink": "#ffc0cb", "darkpink": "#c71585",
      "green": "#00ff00", "darkgreen": "#006400", "lightgreen": "#90ee90", "lime": "#00ff00",
      "blue": "#0000ff", "darkblue": "#00008b", "lightblue": "#add8e6", "cyan": "#00ffff",
      "yellow": "#ffff00", "darkyellow": "#b8860b", "lightyellow": "#ffffe0", "gold": "#ffd700",
      "orange": "#ffa500", "darkorange": "#ff8c00", "lightorange": "#ffd4a3",
      "purple": "#800080", "darkpurple": "#4b0082", "lightpurple": "#d8bfd8", "magenta": "#ff00ff",
      "brown": "#a52a2a", "tan": "#d2b48c", "beige": "#f5f5dc",
    };

    // Default colors if user hasn't set preferences
    const DEFAULT_COLORS = {
      "say": "cyan", "emote": "white", "tell": "yellow", "exits": "darkgreen",
      "weather": "darkyellow", "room_descriptions": "white", "command": "blue",
      "error": "red", "success": "green", "npc": "orange", "system": "gray",
      "wallet": "lightgreen", "quest": "lightblue", "ambiance": "lightgray"
    };

    // Get color for a message type
    function getColorForType(type) {
      const colorName = userColorSettings[type] || DEFAULT_COLORS[type] || "white";
      return COLOR_HEX_MAP[colorName.toLowerCase()] || "#ffffff";
    }

    // Session state tracking
    const sessionState = {
      commandHistory: [], // Array of {command: string, timestamp: Date}
      sessionText: [], // Array of {text: string, timestamp: Date, type: 'output'|'command'}
      theme: 'dark' // 'dark' or 'light'
    };

    // Initialize theme from localStorage if available
    const savedTheme = localStorage.getItem('hollowvale_theme');
    if (savedTheme === 'light') {
      document.body.classList.add('light-mode');
      sessionState.theme = 'light';
    }

    // Track initial output text (if any)
    const initialOutput = outputEl.innerHTML;
    if (initialOutput && initialOutput.trim()) {
      // Check if initial output contains pause markers (onboarding messages)
      const textContent = outputEl.textContent || outputEl.innerText || '';
      if (textContent && (textContent.includes('[PAUSE:') || textContent.includes('[ELLIPSIS:'))) {
        // Clear the output and process with pause markers
        outputEl.innerHTML = '';
        // Process the raw text content (which may have pause markers)
        // Get the original text from the server-rendered content
        appendTextWithPauses(textContent);
      } else {
        // Parse initial HTML content to extract text (normal log entries)
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = initialOutput;
        const textContent = tempDiv.textContent || tempDiv.innerText || '';
        const lines = textContent.split('\n').filter(line => line.trim());
        const initialTimestamp = new Date();
        lines.forEach(line => {
          if (line.trim()) {
            sessionState.sessionText.push({
              text: line.trim(),
              timestamp: initialTimestamp,
              type: 'output'
            });
          }
        });
      }
    }

    // Smart scroll to bottom - only scrolls if user is already near the bottom
    // This prevents interrupting users who are scrolling up to read old messages
    function scrollToBottom(force = false) {
      if (force) {
        // Force scroll (used on page load)
        outputEl.scrollTop = outputEl.scrollHeight;
        return;
      }
      
      // Check if user is near the bottom (within 100px)
      const isNearBottom = (outputEl.scrollHeight - outputEl.scrollTop - outputEl.clientHeight) < 100;
      
      // Only scroll if user is already at or near the bottom
      if (isNearBottom) {
        outputEl.scrollTop = outputEl.scrollHeight;
      }
    }
    
    // Scroll to bottom when page loads (force scroll on initial load)
    window.addEventListener('load', () => {
      setTimeout(() => scrollToBottom(true), 100);
    });
    
    // Also scroll on initial render (force scroll)
    setTimeout(() => scrollToBottom(true), 50);

    function processLogForDisplay(logArray) {
      // Process each log entry to add styling and formatting
      return logArray.map(entry => {
        if (!entry || typeof entry !== 'string') return entry;
        
        let processed = entry;
        
        // Skip if already HTML
        if (processed.includes('<span') || processed.includes('<div')) {
          return processed;
        }
        
        // Highlight command prompts (lines starting with >)
        if (processed.startsWith('> ')) {
          processed = `<span class="command-prompt">${processed}</span>`;
        }
        
        // Highlight Exits:
        processed = processed.replace(/Exits:/g, '<span class="exits-highlight">Exits:</span>');
        
        // Handle type-based color tags (user customizable)
        // Say messages [SAY]...[/SAY] - default cyan
        processed = processed.replace(/\[SAY\](.*?)\[\/SAY\]/g, (match, content) => {
          return `<span style="color: ${getColorForType('say')}; font-weight: 500;">${content}</span>`;
        });
        
        // Emote messages [EMOTE]...[/EMOTE] - default white
        processed = processed.replace(/\[EMOTE\](.*?)\[\/EMOTE\]/g, (match, content) => {
          return `<span style="color: ${getColorForType('emote')}; font-weight: 500;">${content}</span>`;
        });
        
        // Tell messages [TELL]...[/TELL] - default yellow
        processed = processed.replace(/\[TELL\](.*?)\[\/TELL\]/g, (match, content) => {
          return `<span style="color: ${getColorForType('tell')}; font-weight: 500;">${content}</span>`;
        });
        
        // Exit messages [EXITS]...[/EXITS] - default darkgreen
        processed = processed.replace(/\[EXITS\](.*?)\[\/EXITS\]/g, (match, content) => {
          return `<span style="color: ${getColorForType('exits')}; font-weight: bold;">${content}</span>`;
        });
        
        // Weather messages [WEATHER]...[/WEATHER] - default darkyellow
        processed = processed.replace(/\[WEATHER\](.*?)\[\/WEATHER\]/g, (match, content) => {
          return `<span style="color: ${getColorForType('weather')}; font-weight: 500;">${content}</span>`;
        });
        
        // NPC messages [NPC]...[/NPC] - default orange
        processed = processed.replace(/\[NPC\](.*?)\[\/NPC\]/g, (match, content) => {
          return `<span style="color: ${getColorForType('npc')}; font-weight: 500;">${content}</span>`;
        });
        
        // Legacy color tags for backward compatibility
        // Handle cyan color tags [CYAN]...[/CYAN] (maps to 'say' color)
        processed = processed.replace(/\[CYAN\](.*?)\[\/CYAN\]/g, (match, content) => {
          return `<span style="color: ${getColorForType('say')}; font-weight: 500;">${content}</span>`;
        });
        
        // Handle yellow color tags [YELLOW]...[/YELLOW] (maps to 'tell' color)
        processed = processed.replace(/\[YELLOW\](.*?)\[\/YELLOW\]/g, (match, content) => {
          return `<span style="color: ${getColorForType('tell')}; font-weight: 500;">${content}</span>`;
        });
        
        // Handle green color tags [GREEN]...[/GREEN] (maps to 'success' color)
        processed = processed.replace(/\[GREEN\](.*?)\[\/GREEN\]/g, (match, content) => {
          return `<span style="color: ${getColorForType('success')}; font-weight: 500;">${content}</span>`;
        });
        
        // Handle dark green tags [DARK_GREEN]...[/DARK_GREEN] (maps to 'exits' color)
        processed = processed.replace(/\[DARK_GREEN\](.*?)\[\/DARK_GREEN\]/g, (match, content) => {
          return `<span style="color: ${getColorForType('exits')}; font-weight: 500;">${content}</span>`;
        });
        
        // Highlight error messages
        if (processed.includes('[Error') || processed.includes('Error:') || processed.includes("can't") || processed.includes("don't")) {
          processed = `<span class="error-message">${processed}</span>`;
        }
        
        // Highlight success messages (You pick up, You drop, etc.)
        if (processed.match(/^You (pick up|drop|take|give|buy|sell)/i)) {
          processed = `<span class="success-message">${processed}</span>`;
        }
        
        // Highlight NPC messages (NPC says, NPC name:)
        if (processed.match(/^[A-Z][a-z]+ (says|says:|replies|replies:)/) || processed.match(/^[A-Z][a-z]+:/)) {
          processed = `<span class="npc-message">${processed}</span>`;
        }
        
        // Highlight wallet info
        if (processed.includes('Wallet:') || processed.includes('You have') && processed.includes('coin')) {
          processed = processed.replace(/Wallet:.*/g, (match) => `<span class="wallet-info">${match}</span>`);
        }
        
        // Highlight location names (in descriptions)
        if (processed.match(/^(You are in|You stand in|Welcome to) [A-Z]/)) {
          processed = processed.replace(/([A-Z][a-z]+ [A-Z]?[a-z]+ (Town Square|Tavern|Smithy|Lane|Path|Shrine|Watchtower|Forest|Edge))/g, 
            '<span class="location-name">$1</span>');
        }
        
        // Add spacing after certain message types
        if (processed.match(/^(You are carrying|Inventory:|Wallet:)/)) {
          processed = processed + '<br>';
        }
        
        return processed;
      }).join('\n');
    }

    async function appendTextWithPauses(text, forceScroll = false) {
      // Process text with pause markers [PAUSE:seconds] and [ELLIPSIS:seconds]
      // First, extract plain text if HTML is present
      let cleanText = text;
      if (text.includes('<') || text.includes('&')) {
        // Text might contain HTML - extract plain text
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = text;
        cleanText = tempDiv.textContent || tempDiv.innerText || text;
      }
      
      const pauseRegex = /\[(PAUSE|ELLIPSIS):([\d.]+)\]/g;
      const segments = [];
      let lastIndex = 0;
      let match;
      
      // Reset regex lastIndex for global regex
      pauseRegex.lastIndex = 0;
      
      while ((match = pauseRegex.exec(cleanText)) !== null) {
        // Add text before the marker
        if (match.index > lastIndex) {
          const textSegment = cleanText.substring(lastIndex, match.index).trim();
          if (textSegment) {
            segments.push({ type: 'text', content: textSegment, delay: 0 });
          }
        }
        
        // Add pause or ellipsis
        const delay = parseFloat(match[2]);
        if (match[1] === 'ELLIPSIS') {
          segments.push({ type: 'ellipsis', content: '...', duration: delay });
        } else {
          segments.push({ type: 'pause', content: '', duration: delay });
        }
        
        lastIndex = match.index + match[0].length;
      }
      
      // Add remaining text
      if (lastIndex < cleanText.length) {
        const textSegment = cleanText.substring(lastIndex).trim();
        if (textSegment) {
          segments.push({ type: 'text', content: textSegment, delay: 0 });
        }
      }
      
      // If no segments found, treat as regular text
      if (segments.length === 0) {
        segments.push({ type: 'text', content: cleanText, delay: 0 });
      }
      
      // Display segments progressively
      for (const segment of segments) {
        if (segment.type === 'pause') {
          await new Promise(resolve => setTimeout(resolve, segment.duration * 1000));
        } else if (segment.type === 'ellipsis') {
          // Show animated ellipsis
          const ellipsisEl = document.createElement('div');
          ellipsisEl.className = 'ellipsis-indicator';
          ellipsisEl.textContent = '...';
          ellipsisEl.style.fontStyle = 'italic';
          ellipsisEl.style.opacity = '0.7';
          outputEl.appendChild(ellipsisEl);
          scrollToBottom(forceScroll);
          
          await new Promise(resolve => setTimeout(resolve, segment.duration * 1000));
          
          ellipsisEl.remove();
        } else {
          // Regular text - preserve newlines as <br>
          const textEl = document.createElement('div');
          textEl.innerHTML = segment.content.replace(/\n/g, '<br>');
          outputEl.appendChild(textEl);
          scrollToBottom(forceScroll);
          
          // Small delay for readability
          await new Promise(resolve => setTimeout(resolve, 100));
        }
      }
    }

    function appendText(text, showTyping = false, isCommand = false, forceScroll = false) {
      // Track text in session state
      const timestamp = new Date();
      if (typeof text === 'string') {
        sessionState.sessionText.push({
          text: text,
          timestamp: timestamp,
          type: isCommand ? 'command' : 'output'
        });
      } else if (Array.isArray(text)) {
        text.forEach(line => {
          if (line && line.trim()) {
            sessionState.sessionText.push({
              text: line,
              timestamp: timestamp,
              type: 'output'
            });
          }
        });
      }
      
        // Show typing indicator if requested
        if (showTyping) {
          const typingEl = document.createElement('div');
          typingEl.className = 'typing-indicator';
          typingEl.textContent = 'Thinking';
          outputEl.appendChild(typingEl);
          scrollToBottom(forceScroll || false);
        }
      
      // Check if text contains pause markers (onboarding messages)
      if (typeof text === 'string' && (text.includes('[PAUSE:') || text.includes('[ELLIPSIS:'))) {
        appendTextWithPauses(text);
        return;
      }
      
      // If text is a string (from error), process it; if it's an array, process it
      if (typeof text === 'string') {
        // Process string to highlight various elements
        text = text.replace(/Exits:/g, '<span class="exits-highlight">Exits:</span>');
        if (text.includes('[Error') || text.includes('Error:')) {
          text = `<span class="error-message">${text}</span>`;
        }
        const div = document.createElement('div');
        div.innerHTML = text;
        outputEl.appendChild(div);
      } else {
        // Process array of log entries
        text.forEach(line => {
          if (line && line.trim()) {
            const div = document.createElement('div');
            div.innerHTML = processLogForDisplay([line]);
            outputEl.appendChild(div);
          }
        });
      }
      
      // Scroll after DOM is updated
      // Use setTimeout with a small delay to ensure DOM updates are complete before scrolling
      // This is especially important for command responses that may be long
      setTimeout(() => {
        scrollToBottom(forceScroll);
        // Double-check scroll after a brief delay for very long content
        if (forceScroll) {
          setTimeout(() => {
            scrollToBottom(true);
          }, 50);
        }
      }, 10);
    }

    // Meta command handlers
    function handleMetaCommand(cmd) {
      const parts = cmd.split(/\s+/);
      const metaCmd = parts[0].toLowerCase();
      
      switch(metaCmd) {
        case '/clear':
          outputEl.innerHTML = '';
          sessionState.sessionText = [];
          // Add cleared message
          const clearDiv = document.createElement('div');
          clearDiv.innerHTML = '<span class="meta-message">[Console cleared]</span>';
          outputEl.appendChild(clearDiv);
          scrollToBottom(true);
          return true;
          
        case '/print':
          downloadSessionText();
          return true;
          
        case '/history':
          showCommandHistory();
          return true;
          
        case '/dark-mode':
          document.body.classList.remove('light-mode');
          sessionState.theme = 'dark';
          localStorage.setItem('hollowvale_theme', 'dark');
          const darkDiv = document.createElement('div');
          darkDiv.innerHTML = '<span class="meta-message">[Switched to dark mode]</span>';
          outputEl.appendChild(darkDiv);
          scrollToBottom(true);
          return true;
          
        case '/light-mode':
          document.body.classList.add('light-mode');
          sessionState.theme = 'light';
          localStorage.setItem('hollowvale_theme', 'light');
          const lightDiv = document.createElement('div');
          lightDiv.innerHTML = '<span class="meta-message">[Switched to light mode]</span>';
          outputEl.appendChild(lightDiv);
          scrollToBottom(true);
          return true;
          
        default:
          return false; // Not a recognized meta command
      }
    }

    function downloadSessionText() {
      if (sessionState.sessionText.length === 0) {
        appendText(`<span class="meta-message">[No session text to save]</span>`, false);
        return;
      }
      
      // Format text with timestamps
      const lines = [];
      lines.push('=== Hollowvale Game Session Log ===');
      lines.push(`Session Start: ${sessionState.sessionText[0].timestamp.toLocaleString()}`);
      lines.push(`Session End: ${new Date().toLocaleString()}`);
      lines.push('');
      lines.push('--- Session Content ---');
      lines.push('');
      
      sessionState.sessionText.forEach(entry => {
        const timeStr = entry.timestamp.toLocaleTimeString();
        const prefix = entry.type === 'command' ? '> ' : '';
        // Strip HTML tags for plain text file
        const text = entry.text.replace(/<[^>]*>/g, '');
        lines.push(`[${timeStr}] ${prefix}${text}`);
      });
      
      // Create and download file
      const content = lines.join('\n');
      const blob = new Blob([content], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      const filename = `hollowvale_session_${new Date().toISOString().split('T')[0]}_${Date.now()}.txt`;
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      
      appendText(`<span class="meta-message">[Session log saved as ${filename}]</span>`, false);
    }

    function showCommandHistory() {
      if (sessionState.commandHistory.length === 0) {
        appendText(`<span class="meta-message">[No command history]</span>`, false);
        return;
      }
      
      const lines = [];
      lines.push('<span class="meta-message">=== Command History ===</span>');
      sessionState.commandHistory.forEach((entry, index) => {
        const timeStr = entry.timestamp.toLocaleString();
        lines.push(`<span class="meta-message">[${timeStr}] ${entry.command}</span>`);
      });
      
      appendText(lines.join('<br>'), false);
    }

    async function sendCommand() {
      const cmd = commandEl.value.trim();
      if (!cmd) return;
      
      const timestamp = new Date();
      
      // Track command in history (for all commands)
      sessionState.commandHistory.push({
        command: cmd,
        timestamp: timestamp
      });
      
      // Show user's command immediately
      const commandLine = `> ${cmd}`;
      const commandDiv = document.createElement('div');
      commandDiv.innerHTML = `<span class="command-prompt">${commandLine}</span>`;
      outputEl.appendChild(commandDiv);
      
      // Track command in session text
      sessionState.sessionText.push({
        text: cmd,
        timestamp: timestamp,
        type: 'command'
      });
      
      scrollToBottom(true); // Always scroll when command is entered
      
      // Check if it's a meta command (starts with /)
      if (cmd.startsWith('/')) {
        const handled = handleMetaCommand(cmd);
        if (handled) {
          commandEl.value = "";
          commandEl.focus();
          return;
        }
        // If not handled, it's an unknown meta command - show error
        const errorDiv = document.createElement('div');
        errorDiv.innerHTML = `<span class="error-message">[Unknown meta command: ${cmd}. Available: /clear, /print, /history, /dark-mode, /light-mode]</span>`;
        outputEl.appendChild(errorDiv);
        scrollToBottom(true); // Always scroll for command errors
        commandEl.value = "";
        commandEl.focus();
        return;
      }
      
      sendBtn.disabled = true;
      
      // Add slight delay for natural feel (200-400ms)
      const delay = Math.random() * 200 + 200;
      
      try {
        // Show typing indicator
        const typingEl = document.createElement('div');
        typingEl.className = 'typing-indicator';
        typingEl.textContent = 'Thinking';
        outputEl.appendChild(typingEl);
        scrollToBottom(true); // Always scroll when command is entered
        
        await new Promise(resolve => setTimeout(resolve, delay));
        
        const res = await fetch("/command", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          credentials: "same-origin",  // Include session cookies
          body: JSON.stringify({ command: cmd }),
        });
        
        // Remove typing indicator
        const typingIndicators = outputEl.querySelectorAll('.typing-indicator');
        typingIndicators.forEach(el => el.remove());
        
        // Check if response is OK
        if (!res.ok) {
          const errorText = await res.text();
          console.error("Server error:", res.status, errorText);
          // Only show error message, don't duplicate existing content
          appendText(`<span class="error-message">[Error: Server returned ${res.status}. Please try again.]</span>`, false, false, false);
          return;
        }
        
        const data = await res.json();
        
        // Update color settings if provided (user may have changed them)
        if (data.color_settings && typeof data.color_settings === 'object') {
          updateColorSettings(data.color_settings);
        }
        
        // Check if onboarding has completed - if so, clean up onboarding state and start polling
        if (data.onboarding === false && (window.location.search.includes('onboarding=start') || document.body.getAttribute('data-onboarding') === 'true')) {
          console.log("Onboarding completed, cleaning up and starting polling");
          // Remove onboarding parameter from URL without reload
          const url = new URL(window.location);
          url.searchParams.delete('onboarding');
          window.history.replaceState({}, '', url);
          // Remove onboarding attribute from body
          document.body.removeAttribute('data-onboarding');
          // Start polling now that onboarding is complete
          setTimeout(() => {
            startAmbiancePolling();
          }, 1000);
        }
        
        // Check if logout was confirmed
        if (data.logout) {
          // Redirect to logout URL
          window.location.href = "{{ url_for('logout') }}";
          return;
        }
        
        // Pass the log array directly for proper processing
        // Track server response in session text
        console.log("Command response - data.log:", data.log, "type:", typeof data.log, "isArray:", Array.isArray(data.log), "length:", data.log?.length, "data.response:", data.response);
        
        // Display log entries if present
        // Force scroll for command responses so user sees full output
        if (data.log && Array.isArray(data.log) && data.log.length > 0) {
          // Filter out the command line ("> cmd") since we already displayed it immediately
          const filteredLog = data.log.filter(line => {
            if (!line || !line.trim()) return false;
            // Check if this line is the command we just sent (starts with "> " and matches our command)
            const lineText = line.replace(/<[^>]*>/g, '').trim();
            return !(lineText.startsWith('> ') && lineText.substring(2).trim().toLowerCase() === cmd.toLowerCase());
          });
          
          filteredLog.forEach(line => {
            if (line && line.trim()) {
              sessionState.sessionText.push({
                text: line.replace(/<[^>]*>/g, ''), // Store plain text version
                timestamp: new Date(),
                type: 'output'
              });
            }
          });
          appendText(filteredLog, false, false, true); // forceScroll = true for command responses
        } else if (data.response && data.response !== "__LOGOUT__") {
          // If no log entries but there's a response string, show it
          console.log("No log entries, showing response:", data.response);
          sessionState.sessionText.push({
            text: data.response.replace(/<[^>]*>/g, ''),
            timestamp: new Date(),
            type: 'output'
          });
          appendText(data.response, false, false, true); // forceScroll = true for command responses
        } else {
          console.warn("Command returned no log or response:", data);
        }
      } catch (e) {
        // Remove typing indicator on error
        const typingIndicators = outputEl.querySelectorAll('.typing-indicator');
        typingIndicators.forEach(el => el.remove());
        
        console.error("Error sending command:", e);
        // Only show error message, don't append the entire outputEl.innerHTML (that causes duplication)
        appendText(`<span class="error-message">[Error sending command. Please check your connection and try again.]</span>`, false, false, false);
      } finally {
        commandEl.value = "";
        commandEl.focus();
        sendBtn.disabled = false;
      }
    }

    sendBtn.addEventListener("click", sendCommand);
    commandEl.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        e.preventDefault();
        sendCommand();
      }
    });

    // Focus input on load and scroll to bottom (force scroll on initial load)
    window.addEventListener('load', () => {
      commandEl.focus();
      setTimeout(() => scrollToBottom(true), 100);
    });
    
    // Also scroll on DOMContentLoaded (force scroll)
    document.addEventListener('DOMContentLoaded', () => {
      setTimeout(() => scrollToBottom(true), 50);
    });
    
    // Initial scroll (force scroll)
    setTimeout(() => scrollToBottom(true), 50);
    
    // Real-time ambiance polling - check for new messages every 5 seconds
    // This makes the world feel alive even when the player is idle
    let pollInterval = null;
    let isPollingActive = false;
    
    function startAmbiancePolling() {
      // Don't start polling during onboarding
      const isOnboarding = document.body.getAttribute('data-onboarding') === 'true' || 
                          window.location.search.includes('onboarding=start');
      if (isOnboarding) {
        console.log("Onboarding detected, skipping polling");
        return;
      }
      
      if (pollInterval || isPollingActive) {
        console.log("Polling already active, skipping start");
        return; // Already polling
      }
      
      console.log("Starting ambiance polling...");
      isPollingActive = true;
      pollInterval = setInterval(async () => {
        try {
          // Check if we're in onboarding before polling
          const urlParams = new URLSearchParams(window.location.search);
          if (urlParams.get('onboarding') === 'start' || document.body.getAttribute('data-onboarding') === 'true') {
            console.log("Onboarding detected, stopping polling");
            stopAmbiancePolling();
            return;
          }
          
          console.log("Polling for updates...");
          const res = await fetch("/poll", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            credentials: "same-origin"
          });
          
          console.log("Poll response status:", res.status);
          
          if (!res.ok) {
            // If unauthorized, redirected, or error, stop polling
            if (res.status === 401 || res.status === 403 || res.status === 302) {
              console.error("Polling unauthorized/redirected, stopping");
              stopAmbiancePolling();
            } else {
              console.warn("Polling returned non-OK status:", res.status);
            }
            return;
          }
          
          // Check content type before parsing
          const contentType = res.headers.get("content-type") || "";
          if (!contentType.includes("application/json")) {
            console.error("Poll response is not JSON, stopping polling");
            stopAmbiancePolling();
            return;
          }
          
          const data = await res.json();
          console.log("Poll response data:", data);
          
          if (data.messages && Array.isArray(data.messages) && data.messages.length > 0) {
            console.log("Received", data.messages.length, "new messages from poll");
            // Append new messages to output
            appendText(data.messages, false);
          } else {
            console.log("No new messages in poll response");
          }
        } catch (e) {
          console.error("Error polling for ambiance:", e);
          // Don't stop polling on transient errors - just log and continue
        }
      }, 3000); // Poll every 3 seconds for more responsive real-time updates
      
      console.log("Polling interval set, will poll every 3 seconds");
    }
    
    function stopAmbiancePolling() {
      if (pollInterval) {
        clearInterval(pollInterval);
        pollInterval = null;
      }
      isPollingActive = false;
    }
    
    // Start polling when page loads (only if user is logged in)
    // Also start immediately if DOM is already loaded
    console.log("Setting up polling, DOM readyState:", document.readyState);
    
    function initPolling() {
      console.log("Initializing polling...");
      // Small delay to ensure session is ready
      setTimeout(() => {
        console.log("Starting ambiance polling after delay");
        startAmbiancePolling();
      }, 1000);
    }
    
    if (document.readyState === 'loading') {
      console.log("DOM still loading, waiting for load event");
      window.addEventListener('load', () => {
        console.log("Window load event fired");
        initPolling();
      });
    } else {
      // DOM already loaded, start polling immediately
      console.log("DOM already loaded, starting polling immediately");
      initPolling();
    }
    
    // Also try starting when DOMContentLoaded fires (backup)
    document.addEventListener('DOMContentLoaded', () => {
      console.log("DOMContentLoaded fired");
      if (!isPollingActive && !pollInterval) {
        console.log("Polling not active yet, starting from DOMContentLoaded");
        setTimeout(() => {
          startAmbiancePolling();
        }, 500);
      }
    });
    
    // Stop polling when page unloads
    window.addEventListener('beforeunload', () => {
      stopAmbiancePolling();
    });
  </script>
</body>
</html>
