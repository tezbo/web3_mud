<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Tiny Web MUD</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5, user-scalable=yes">
  <meta name="theme-color" content="#0a0a0a">
  <style>
    * {
      box-sizing: border-box;
    }
    body {
      background: linear-gradient(135deg, #0a0a0a 0%, #1a1a1a 50%, #0a0a0a 100%);
      background-attachment: fixed;
      color: #e0e0e0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      height: 100vh;
      overflow: hidden;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }
    .container {
      display: flex;
      flex-direction: column;
      max-width: 900px;
      width: 100%;
      margin: 0 auto;
      padding: clamp(8px, 2vw, 16px);
      flex: 1;
      min-height: 0;
      overflow: hidden;
    }
    .top-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: clamp(12px, 2vw, 16px);
      padding-bottom: clamp(12px, 2vw, 16px);
      border-bottom: 1px solid #333;
      font-size: clamp(12px, 3vw, 14px);
      flex-shrink: 0;
      flex-wrap: wrap;
      gap: 8px;
    }
    .top-bar > div {
      display: flex;
      align-items: center;
      gap: 12px;
      flex-wrap: wrap;
    }
    .top-bar a {
      color: #60a5fa;
      text-decoration: none;
      transition: all 0.3s ease;
      padding: 6px 12px;
      border-radius: 6px;
      font-weight: 500;
    }
    .top-bar a:hover {
      color: #93c5fd;
      text-decoration: none;
      background: rgba(96, 165, 250, 0.1);
    }
    .top-bar strong {
      color: #f0f0f0;
      font-weight: 600;
    }
    #output {
      flex: 1;
      border: 1px solid #333;
      border-radius: 8px;
      padding: clamp(12px, 3vw, 16px);
      overflow-y: auto;
      white-space: pre-wrap;
      background: rgba(15, 15, 15, 0.95);
      font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
      font-size: clamp(12px, 3vw, 14px);
      line-height: 1.7;
      word-wrap: break-word;
      -webkit-overflow-scrolling: touch;
    }
    /* Scrollbar styling */
    #output::-webkit-scrollbar {
      width: 8px;
    }
    #output::-webkit-scrollbar-track {
      background: #1a1a1a;
      border-radius: 4px;
    }
    #output::-webkit-scrollbar-thumb {
      background: #444;
      border-radius: 4px;
    }
    #output::-webkit-scrollbar-thumb:hover {
      background: #555;
    }
    /* Text styling classes */
    #output .command-prompt {
      color: #60a5fa;
      font-weight: 600;
    }
    #output .system-message {
      color: #9ca3af;
      font-style: italic;
    }
    #output .error-message {
      color: #f87171;
      font-weight: 500;
    }
    #output .success-message {
      color: #34d399;
    }
    #output .npc-message {
      color: #fbbf24;
      font-weight: 500;
    }
    #output .location-name {
      color: #a78bfa;
      font-weight: 600;
      font-size: 15px;
    }
    #output .item-name {
      color: #60a5fa;
      font-weight: 500;
    }
    #output .exits-highlight {
      color: #fbbf24;
      font-weight: bold;
    }
    #output .wallet-info {
      color: #34d399;
      font-weight: 500;
    }
    #output .cyan-message {
      color: #00ffff;
      font-weight: 500;
    }
    /* Spacing between messages */
    #output > * {
      margin-bottom: 8px;
    }
    .input-row {
      display: flex;
      margin-top: 12px;
      gap: 10px;
      flex-shrink: 0;
    }
    #command {
      flex: 1;
      padding: clamp(12px, 3vw, 14px);
      border-radius: 8px;
      border: 1px solid #333;
      background: #1a1a1a;
      color: #e0e0e0;
      font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
      font-size: 16px; /* Prevents zoom on iOS */
      transition: all 0.3s ease;
      -webkit-appearance: none;
      appearance: none;
    }
    #command:focus {
      outline: none;
      border-color: #60a5fa;
      box-shadow: 0 0 0 3px rgba(96, 165, 250, 0.1);
      background: #1f1f1f;
    }
    button {
      padding: clamp(12px, 3vw, 14px) clamp(18px, 4vw, 20px);
      border-radius: 8px;
      border: none;
      background: #3b82f6;
      color: #fff;
      font-size: clamp(13px, 3vw, 14px);
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      min-height: 44px; /* Touch-friendly */
      white-space: nowrap;
    }
    button:hover:not(:disabled) {
      background: #2563eb;
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
    }
    button:active:not(:disabled) {
      transform: translateY(0);
    }
    button:disabled {
      opacity: 0.6;
      cursor: default;
    }
    /* Mobile optimizations */
    @media (max-width: 480px) {
      .container {
        padding: 8px;
      }
      .top-bar {
        flex-direction: column;
        align-items: flex-start;
      }
      .top-bar > div {
        width: 100%;
        justify-content: space-between;
      }
      #output {
        padding: 12px;
        font-size: 12px;
      }
      #command {
        padding: 14px;
      }
      button {
        padding: 14px 16px;
        min-width: 70px;
      }
    }
    /* Touch-friendly improvements */
    @media (hover: none) and (pointer: coarse) {
      button {
        min-height: 48px;
      }
      .top-bar a {
        min-height: 44px;
        display: inline-flex;
        align-items: center;
      }
    }
    /* Typing indicator */
    .typing-indicator {
      color: #9ca3af;
      font-style: italic;
      opacity: 0.7;
    }
    .typing-indicator::after {
      content: '...';
      animation: dots 1.5s steps(4, end) infinite;
    }
    @keyframes dots {
      0%, 20% { content: '.'; }
      40% { content: '..'; }
      60%, 100% { content: '...'; }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="top-bar">
      <div>
        {% if session.username %}
          Logged in as <strong>{{ session.username }}</strong>
        {% endif %}
      </div>
      <div>
        <a href="{{ url_for('guide') }}" style="margin-right: 15px;">ðŸ“œ Guide</a>
        <a href="{{ url_for('logout') }}">Log out</a>
      </div>
    </div>
    <div id="output">{{ "\n".join(log) | safe }}</div>
    <div class="input-row">
      <input id="command" type="text" placeholder="Type a command (try: look, go north, inventory, help)" autocomplete="off">
      <button id="sendBtn">Send</button>
    </div>
  </div>

  <script>
    const outputEl = document.getElementById("output");
    const commandEl = document.getElementById("command");
    const sendBtn = document.getElementById("sendBtn");

    // Auto-scroll to bottom on page load
    function scrollToBottom() {
      outputEl.scrollTop = outputEl.scrollHeight;
    }
    
    // Scroll to bottom when page loads
    window.addEventListener('load', () => {
      setTimeout(scrollToBottom, 100);
    });
    
    // Also scroll on initial render
    setTimeout(scrollToBottom, 50);

    function processLogForDisplay(logArray) {
      // Process each log entry to add styling and formatting
      return logArray.map(entry => {
        if (!entry || typeof entry !== 'string') return entry;
        
        let processed = entry;
        
        // Skip if already HTML
        if (processed.includes('<span') || processed.includes('<div')) {
          return processed;
        }
        
        // Highlight command prompts (lines starting with >)
        if (processed.startsWith('> ')) {
          processed = `<span class="command-prompt">${processed}</span>`;
        }
        
        // Highlight Exits:
        processed = processed.replace(/Exits:/g, '<span class="exits-highlight">Exits:</span>');
        
        // Handle cyan color tags [CYAN]...[/CYAN]
        processed = processed.replace(/\[CYAN\](.*?)\[\/CYAN\]/g, '<span class="cyan-message">$1</span>');
        
        // Highlight error messages
        if (processed.includes('[Error') || processed.includes('Error:') || processed.includes("can't") || processed.includes("don't")) {
          processed = `<span class="error-message">${processed}</span>`;
        }
        
        // Highlight success messages (You pick up, You drop, etc.)
        if (processed.match(/^You (pick up|drop|take|give|buy|sell)/i)) {
          processed = `<span class="success-message">${processed}</span>`;
        }
        
        // Highlight NPC messages (NPC says, NPC name:)
        if (processed.match(/^[A-Z][a-z]+ (says|says:|replies|replies:)/) || processed.match(/^[A-Z][a-z]+:/)) {
          processed = `<span class="npc-message">${processed}</span>`;
        }
        
        // Highlight wallet info
        if (processed.includes('Wallet:') || processed.includes('You have') && processed.includes('coin')) {
          processed = processed.replace(/Wallet:.*/g, (match) => `<span class="wallet-info">${match}</span>`);
        }
        
        // Highlight location names (in descriptions)
        if (processed.match(/^(You are in|You stand in|Welcome to) [A-Z]/)) {
          processed = processed.replace(/([A-Z][a-z]+ [A-Z]?[a-z]+ (Town Square|Tavern|Smithy|Lane|Path|Shrine|Watchtower|Forest|Edge))/g, 
            '<span class="location-name">$1</span>');
        }
        
        // Add spacing after certain message types
        if (processed.match(/^(You are carrying|Inventory:|Wallet:)/)) {
          processed = processed + '<br>';
        }
        
        return processed;
      }).join('\n');
    }

    async function appendTextWithPauses(text) {
      // Process text with pause markers [PAUSE:seconds] and [ELLIPSIS:seconds]
      const pauseRegex = /\[(PAUSE|ELLIPSIS):([\d.]+)\]/g;
      const segments = [];
      let lastIndex = 0;
      let match;
      
      while ((match = pauseRegex.exec(text)) !== null) {
        // Add text before the marker
        if (match.index > lastIndex) {
          const textSegment = text.substring(lastIndex, match.index).trim();
          if (textSegment) {
            segments.push({ type: 'text', content: textSegment, delay: 0 });
          }
        }
        
        // Add pause or ellipsis
        const delay = parseFloat(match[2]);
        if (match[1] === 'ELLIPSIS') {
          segments.push({ type: 'ellipsis', content: '...', duration: delay });
        } else {
          segments.push({ type: 'pause', content: '', duration: delay });
        }
        
        lastIndex = match.index + match[0].length;
      }
      
      // Add remaining text
      if (lastIndex < text.length) {
        const textSegment = text.substring(lastIndex).trim();
        if (textSegment) {
          segments.push({ type: 'text', content: textSegment, delay: 0 });
        }
      }
      
      // If no segments found, treat as regular text
      if (segments.length === 0) {
        segments.push({ type: 'text', content: text, delay: 0 });
      }
      
      // Display segments progressively
      for (const segment of segments) {
        if (segment.type === 'pause') {
          await new Promise(resolve => setTimeout(resolve, segment.duration * 1000));
        } else if (segment.type === 'ellipsis') {
          // Show animated ellipsis
          const ellipsisEl = document.createElement('div');
          ellipsisEl.className = 'ellipsis-indicator';
          ellipsisEl.textContent = '...';
          ellipsisEl.style.fontStyle = 'italic';
          ellipsisEl.style.opacity = '0.7';
          outputEl.appendChild(ellipsisEl);
          scrollToBottom();
          
          await new Promise(resolve => setTimeout(resolve, segment.duration * 1000));
          
          ellipsisEl.remove();
        } else {
          // Regular text
          const textEl = document.createElement('div');
          textEl.innerHTML = processLogForDisplay([segment.content]);
          outputEl.appendChild(textEl);
          scrollToBottom();
          
          // Small delay for readability
          await new Promise(resolve => setTimeout(resolve, 100));
        }
      }
    }

    function appendText(text, showTyping = false) {
      // Show typing indicator if requested
      if (showTyping) {
        const typingEl = document.createElement('div');
        typingEl.className = 'typing-indicator';
        typingEl.textContent = 'Thinking';
        outputEl.appendChild(typingEl);
        scrollToBottom();
      }
      
      // Check if text contains pause markers (onboarding messages)
      if (typeof text === 'string' && (text.includes('[PAUSE:') || text.includes('[ELLIPSIS:'))) {
        appendTextWithPauses(text);
        return;
      }
      
      // If text is a string (from error), process it; if it's an array, process it
      if (typeof text === 'string') {
        // Process string to highlight various elements
        text = text.replace(/Exits:/g, '<span class="exits-highlight">Exits:</span>');
        if (text.includes('[Error') || text.includes('Error:')) {
          text = `<span class="error-message">${text}</span>`;
        }
        outputEl.innerHTML = text;
      } else {
        // Process array of log entries
        outputEl.innerHTML = processLogForDisplay(text);
      }
      scrollToBottom();
    }

    async function sendCommand() {
      const cmd = commandEl.value.trim();
      if (!cmd) return;
      
      // Show user's command immediately
      const commandLine = `> ${cmd}`;
      appendText(outputEl.innerHTML + '\n' + `<span class="command-prompt">${commandLine}</span>`, false);
      
      sendBtn.disabled = true;
      
      // Add slight delay for natural feel (200-400ms)
      const delay = Math.random() * 200 + 200;
      
      try {
        // Show typing indicator
        const typingEl = document.createElement('div');
        typingEl.className = 'typing-indicator';
        typingEl.textContent = 'Thinking';
        outputEl.appendChild(typingEl);
        scrollToBottom();
        
        await new Promise(resolve => setTimeout(resolve, delay));
        
        const res = await fetch("/command", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ command: cmd }),
        });
        
        // Remove typing indicator
        const typingIndicators = outputEl.querySelectorAll('.typing-indicator');
        typingIndicators.forEach(el => el.remove());
        
        // Check if response is OK
        if (!res.ok) {
          const errorText = await res.text();
          console.error("Server error:", res.status, errorText);
          appendText(outputEl.innerHTML + `\n<span class="error-message">[Error: Server returned ${res.status}. Please try again.]</span>`, false);
          return;
        }
        
        const data = await res.json();
        
        // Check if logout was confirmed
        if (data.logout) {
          // Redirect to logout URL
          window.location.href = "{{ url_for('logout') }}";
          return;
        }
        
        // Pass the log array directly for proper processing
        appendText(data.log, false);
      } catch (e) {
        // Remove typing indicator on error
        const typingIndicators = outputEl.querySelectorAll('.typing-indicator');
        typingIndicators.forEach(el => el.remove());
        
        console.error("Error sending command:", e);
        appendText(outputEl.innerHTML + `\n<span class="error-message">[Error sending command. Please check your connection and try again.]</span>`, false);
      } finally {
        commandEl.value = "";
        commandEl.focus();
        sendBtn.disabled = false;
      }
    }

    sendBtn.addEventListener("click", sendCommand);
    commandEl.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        e.preventDefault();
        sendCommand();
      }
    });

    // Focus input on load and scroll to bottom
    window.addEventListener('load', () => {
      commandEl.focus();
      setTimeout(scrollToBottom, 100);
    });
    
    // Also scroll on DOMContentLoaded
    document.addEventListener('DOMContentLoaded', () => {
      setTimeout(scrollToBottom, 50);
    });
    
    // Initial scroll
    setTimeout(scrollToBottom, 50);
  </script>
</body>
</html>
