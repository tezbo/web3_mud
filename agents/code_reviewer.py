"""
Code Reviewer Agent - Discworld-Quality Standards

This agent reviews content generated by other agents, ensuring it meets
the high standards of immersion, lore consistency, and narrative quality
inspired by Discworld MUD.
"""

import os
import json
import time
import openai
from pathlib import Path
from datetime import datetime
from dotenv import load_dotenv
from agents.agent_framework import AutonomousAgent

load_dotenv()

class CodeReviewerAgent(AutonomousAgent):
    def __init__(self):
        super().__init__(
            name="Code Reviewer",
            role="Quality Assurance",
            capabilities=["review", "quality", "lore", "python_review"]
        )
        
        # Discworld-quality standards (legacy/content checks)
        self.quality_standards = {
            "sensory_richness": [
                "smell", "sound", "texture", "taste", "sight",
                "scent", "aroma", "echo", "whisper", "gleam"
            ],
            "immersion_keywords": [
                "shadows", "flickering", "damp", "musty", "weathered",
                "worn", "ancient", "crumbling", "bustling", "quiet"
            ],
            "narrative_quality": [
                "story", "history", "legend", "tale", "memory",
                "secret", "mystery", "rumor", "whisper"
            ]
        }
        
        # OpenAI Configuration
        self.openai_api_key = os.getenv("OPENAI_API_KEY")
        self.openai_model = os.getenv("OPENAI_MODEL", "gpt-4o-mini")
        
        if self.openai_api_key:
            self.client = openai.OpenAI(api_key=self.openai_api_key)
        else:
            self.client = None
            self.log("‚ö†Ô∏è OPENAI_API_KEY not found. AI review features disabled.")
    
    def find_task(self):
        """Find tasks marked as 'review_ready'."""
        try:
            with open('agent_tasks.json', 'r') as f:
                data = json.load(f)
            
            for task in data.get('tasks', []):
                if task['status'] == 'review_ready':
                    return task
            return None
        except Exception as e:
            self.log(f"Error finding task: {e}")
            return None
    
    def execute_task(self, task):
        """Review the task's generated content."""
        self.log(f"üßê Reviewing task: {task['title']}...")
        
        # Find files created by this task
        output_dir = Path("agents/outputs/shadowfen") # Default output dir
        task_files = self._find_task_files(task, output_dir)
        
        # Also check for root python files if it's a code task
        if not task_files and "code" in task['title'].lower():
            # Logic to find relevant python files (simplified for now)
            pass
            
        if not task_files:
            self.log("‚ö†Ô∏è No files found to review")
            # For now, don't fail, just log
            return
        
        # Review each file
        issues = []
        for file_path in task_files:
            self.log(f"üìÑ Reviewing {file_path.name}...")
            
            if file_path.suffix == '.py':
                # Use Real AI Review for Python files
                file_issues = self._review_python_with_ai(file_path)
            else:
                # Use Legacy Content Review for text files
                file_issues = self._review_content(file_path, task)
                
            issues.extend(file_issues)
        
        # Decide approval
        if len(issues) == 0:
            self.log("‚úÖ Content meets standards! Approving.")
            self._update_task_status(task['id'], 'approved')
        elif len(issues) <= 2:
            self.log(f"‚úì Approved with {len(issues)} minor notes:")
            for issue in issues:
                self.log(f"  üìù {issue}")
            self._update_task_status(task['id'], 'approved')
        else:
            self.log(f"‚ùå Found {len(issues)} issues. Requesting revisions.")
            for issue in issues:
                self.log(f"  - {issue}")
            self._update_task_status(task['id'], 'failed')
        
        time.sleep(2)
    
    def _review_python_with_ai(self, file_path):
        """Review Python code using OpenAI API."""
        if not self.client:
            self.log("‚ö†Ô∏è Skipping AI review (no key)")
            return ["AI review unavailable (missing API key)"]
            
        try:
            with open(file_path, "r") as f:
                code_content = f.read()
                
            prompt = f"""
            Review this Python code for quality, type hints, docstrings, and PEP 8.
            Return JSON: {{ "issues": ["list", "of", "issues"], "fixed_code": "full code if fixes needed" }}
            
            CODE:
            {code_content}
            """
            
            response = self.client.chat.completions.create(
                model=self.openai_model,
                messages=[
                    {"role": "system", "content": "You are a code reviewer. Output JSON only."},
                    {"role": "user", "content": prompt}
                ],
                response_format={"type": "json_object"}
            )
            
            result = json.loads(response.choices[0].message.content)
            issues = result.get('issues', [])
            fixed_code = result.get('fixed_code')
            
            if issues and fixed_code:
                self.log(f"ü§ñ AI found {len(issues)} issues. Applying fixes...")
                with open(file_path, "w") as f:
                    f.write(fixed_code)
                self.log("‚úÖ AI fixes applied")
                
            return issues
            
        except Exception as e:
            self.log(f"AI Review Error: {e}")
            return [f"AI Review Error: {str(e)}"]

    def _find_task_files(self, task, output_dir):
        """Find files related to this task."""
        task_files = []
        if not output_dir.exists():
            return []
            
        task_title_slug = task['title'].lower().replace(' ', '_').replace("'", '')
        
        for file_path in output_dir.glob("*"):
            if task_title_slug in file_path.name.lower():
                task_files.append(file_path)
                
        return task_files
    
    def _review_content(self, file_path, task):
        """Review text content for Discworld standards (Legacy)."""
        issues = []
        try:
            content = file_path.read_text()
            # Check 1: Minimum length
            if len(content) < 200:
                issues.append(f"{file_path.name}: Too brief.")
            
            # Check 2: Sensory richness
            sensory_count = sum(1 for word in self.quality_standards["sensory_richness"] 
                              if word in content.lower())
            if sensory_count < 2:
                issues.append(f"{file_path.name}: Lacks sensory details.")
                
        except Exception as e:
            issues.append(f"Error reading file: {e}")
        
        return issues
    
    def _update_task_status(self, task_id, new_status):
        """Update task status in agent_tasks.json."""
        try:
            with open('agent_tasks.json', 'r') as f:
                data = json.load(f)
            
            for task in data.get('tasks', []):
                if task['id'] == task_id:
                    task['status'] = new_status
                    task['updated_at'] = datetime.utcnow().isoformat() + 'Z'
                    break
            
            with open('agent_tasks.json', 'w') as f:
                json.dump(data, f, indent=2)
        except Exception as e:
            self.log(f"Error updating task status: {e}")


if __name__ == "__main__":
    agent = CodeReviewerAgent()
    agent.run_loop()
