"""
Code Reviewer Agent - Discworld-Quality Standards

This agent reviews content generated by other agents, ensuring it meets
the high standards of immersion, lore consistency, and narrative quality
inspired by Discworld MUD.
"""

import json
import time
from pathlib import Path
from datetime import datetime
from agents.agent_framework import AutonomousAgent


class CodeReviewerAgent(AutonomousAgent):
    def __init__(self):
        super().__init__(
            name="Code Reviewer",
            role="Quality Assurance",
            capabilities=["review", "quality", "lore"]
        )
        
        # Discworld-quality standards
        self.quality_standards = {
            "sensory_richness": [
                "smell", "sound", "texture", "taste", "sight",
                "scent", "aroma", "echo", "whisper", "gleam"
            ],
            "immersion_keywords": [
                "shadows", "flickering", "damp", "musty", "weathered",
                "worn", "ancient", "crumbling", "bustling", "quiet"
            ],
            "narrative_quality": [
                "story", "history", "legend", "tale", "memory",
                "secret", "mystery", "rumor", "whisper"
            ]
        }
    
    def find_task(self):
        """Find tasks marked as 'review_ready'."""
        try:
            with open('agent_tasks.json', 'r') as f:
                data = json.load(f)
            
            for task in data.get('tasks', []):
                if task['status'] == 'review_ready':
                    return task
            return None
        except Exception as e:
            self.log(f"Error finding task: {e}")
            return None
    
    def execute_task(self, task):
        """Review the task's generated content with Discworld-quality standards."""
        self.log(f"üßê Reviewing task: {task['title']}...")
        
        # Find files created by this task
        output_dir = Path("agents/outputs/shadowfen")
        task_files = self._find_task_files(task, output_dir)
        
        if not task_files:
            self.log("‚ö†Ô∏è No files found to review")
            self._update_task_status(task['id'], 'failed')
            return
        
        # Review each file
        issues = []
        for file_path in task_files:
            self.log(f"üìÑ Reviewing {file_path.name}...")
            file_issues = self._review_file(file_path, task)
            issues.extend(file_issues)
        
        # Decide approval based on Discworld standards
        if len(issues) == 0:
            self.log("‚úÖ Content meets Discworld-quality standards! Approving.")
            self._update_task_status(task['id'], 'approved')
        elif len(issues) <= 2:
            # Minor issues - approve with notes
            self.log(f"‚úì Approved with {len(issues)} minor notes:")
            for issue in issues:
                self.log(f"  üìù {issue}")
            self._update_task_status(task['id'], 'approved')
        else:
            self.log(f"‚ùå Found {len(issues)} issues. Requesting revisions.")
            for issue in issues:
                self.log(f"  - {issue}")
            self._update_task_status(task['id'], 'failed')
        
        time.sleep(2)  # Simulate review time
    
    def _find_task_files(self, task, output_dir):
        """Find files related to this task."""
        task_files = []
        
        # Create output dir if it doesn't exist
        output_dir.mkdir(parents=True, exist_ok=True)
        
        # Look for files matching task patterns
        task_title_slug = task['title'].lower().replace(' ', '_').replace("'", '')
        
        for file_path in output_dir.glob("*.txt"):
            if task_title_slug in file_path.name.lower():
                task_files.append(file_path)
        
        # Also check for recent files (created in last 5 minutes)
        if not task_files:
            current_time = time.time()
            for file_path in output_dir.glob("*.txt"):
                if current_time - file_path.stat().st_mtime < 300:  # 5 minutes
                    task_files.append(file_path)
        
        return task_files
    
    def _review_file(self, file_path, task):
        """Review a file for Discworld-quality standards."""
        issues = []
        
        try:
            content = file_path.read_text()
            
            # Check 1: Minimum length (no lazy descriptions)
            if len(content) < 200:
                issues.append(f"{file_path.name}: Too brief. Discworld descriptions are rich and detailed.")
            
            # Check 2: Sensory richness
            sensory_count = sum(1 for word in self.quality_standards["sensory_richness"] 
                              if word in content.lower())
            if sensory_count < 2:
                issues.append(f"{file_path.name}: Lacks sensory details. Add smells, sounds, textures.")
            
            # Check 3: Immersion keywords
            immersion_count = sum(1 for word in self.quality_standards["immersion_keywords"] 
                                if word in content.lower())
            if immersion_count < 1:
                issues.append(f"{file_path.name}: Needs more atmospheric details.")
            
            # Check 4: Narrative quality (for quests)
            if 'quest' in task['title'].lower():
                narrative_count = sum(1 for word in self.quality_standards["narrative_quality"] 
                                    if word in content.lower())
                if narrative_count < 1:
                    issues.append(f"{file_path.name}: Quest needs more story/lore hooks.")
            
            # Check 5: No generic fantasy clich√©s
            cliches = ["dark and stormy", "brave hero", "evil wizard", "chosen one"]
            for cliche in cliches:
                if cliche in content.lower():
                    issues.append(f"{file_path.name}: Contains clich√© '{cliche}'. Be more original.")
            
            # Check 6: Proper formatting
            if not content.strip():
                issues.append(f"{file_path.name}: File is empty.")
            
        except Exception as e:
            issues.append(f"{file_path.name}: Error reading file - {e}")
        
        return issues
    
    def _update_task_status(self, task_id, new_status):
        """Update task status in agent_tasks.json."""
        try:
            with open('agent_tasks.json', 'r') as f:
                data = json.load(f)
            
            for task in data.get('tasks', []):
                if task['id'] == task_id:
                    task['status'] = new_status
                    task['updated_at'] = datetime.utcnow().isoformat() + 'Z'
                    break
            
            with open('agent_tasks.json', 'w') as f:
                json.dump(data, f, indent=2)
        except Exception as e:
            self.log(f"Error updating task status: {e}")


if __name__ == "__main__":
    agent = CodeReviewerAgent()
    agent.run_loop()
