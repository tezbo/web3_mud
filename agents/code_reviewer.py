"""
Code Reviewer Agent - High-Quality Standards

This agent reviews content generated by other agents, ensuring it meets
the high standards of immersion, lore consistency, and narrative quality
inspired by the best MUDs.
"""

import json
import time
from pathlib import Path
from datetime import datetime
from agents.agent_framework import AutonomousAgent


class CodeReviewerAgent(AutonomousAgent):
    def __init__(self):
        super().__init__(
            name="Code Reviewer",
            role="Quality Assurance",
            capabilities=["review", "quality", "lore"]
        )
        
        # High-quality standards
        self.quality_standards = {
            "sensory_richness": [
                "smell", "sound", "texture", "taste", "sight",
                "scent", "aroma", "echo", "whisper", "gleam"
            ],
            "immersion_keywords": [
                "shadows", "flickering", "damp", "musty", "weathered",
                "worn", "ancient", "crumbling", "bustling", "quiet"
            ],
            "narrative_quality": [
                "story", "history", "legend", "tale", "memory",
                "secret", "mystery", "rumor", "whisper"
            ]
        }
    
    def find_task(self):
        """Find tasks marked as 'review_ready'."""
        try:
            with open('agent_tasks.json', 'r') as f:
                data = json.load(f)
            
            for task in data.get('tasks', []):
                if task['status'] == 'review_ready':
                    return task
            return None
        except Exception as e:
            self.log(f"Error finding task: {e}")
            return None
    
    def execute_task(self, task):
        """Review the task's generated content with high-quality standards."""
        self.log(f"üßê Reviewing task: {task['title']}...")
        
        # Find files created by this task
        output_dir = Path("agents/outputs/shadowfen")
        task_files = self._find_task_files(task, output_dir)
        
        if not task_files:
            self.log("‚ö†Ô∏è No files found to review")
            self._update_task_status(task['id'], 'failed')
            return
        
        # Review each file
        issues = []
        for file_path in task_files:
            self.log(f"üìÑ Reviewing {file_path.name}...")
            file_issues = self._review_file(file_path, task)
            issues.extend(file_issues)
        
        # Decide approval based on high-quality standards
        if len(issues) == 0:
            self.log("‚úÖ Content meets high-quality standards! Approving.")
            self._update_task_status(task['id'], 'approved')
        elif len(issues) <= 2:
            # Minor issues - approve with notes
            self.log(f"‚úì Approved with {len(issues)} minor notes:")
            for issue in issues:
                self.log(f"  üìù {issue}")
            self._update_task_status(task['id'], 'approved')
        else:
            self.log(f"‚ùå Found {len(issues)} issues. Requesting revisions.")
            for issue in issues:
                self.log(f"  - {issue}")
            self._update_task_status(task['id'], 'failed')
        
        time.sleep(2)  # Simulate review time
    
    def _find_task_files(self, task, output_dir):
        """Find files related to this task."""
        task_files = []
        
        # Create output dir if it doesn't exist
        output_dir.mkdir(parents=True, exist_ok=True)
        
        # Look for files matching task patterns
        task_title_slug = task['title'].lower().replace(' ', '_').replace("'", '')
        
        for file_path in output_dir.glob("*.txt"):
            if task_title_slug in file_path.name.lower():
                task_files.append(file_path)
        
        # Also check for recent files (created in last 5 minutes)
        if not task_files:
            current_time = time.time()
            for file_path in output_dir.glob("*.txt"):
                if current_time - file_path.stat().st_mtime < 300:  # 5 minutes
                    task_files.append(file_path)
        
        return task_files
    
    def _review_file(self, file_path, task):
        """Review a file for Discworld-quality standards."""
        issues = []
        
        try:
            content = file_path.read_text()
            
            # Check 1: Minimum length (no lazy descriptions)
            if len(content) < 200:
                issues.append(f"{file_path.name}: Too brief. The descriptions need to be rich and detailed.")
            
            # Check 2: Sensory richness
            sensory_count = sum(1 for word in self.quality_standards["sensory_richness"] 
                              if word in content.lower())
            if sensory_count < 2:
                issues.append(f"{file_path.name}: Lacks sensory details. Add smells, sounds, textures.")
            
            # Check 3: Immersion keywords
            immersion_count = sum(1 for word in self.quality_standards["immersion_keywords"] 
                                if word in content.lower())
            if immersion_count < 1:
                issues.append(f"{file_path.name}: Needs more atmospheric details.")
            
            # Check 4: Narrative quality (for quests)
            if 'quest' in task['title'].lower():
                narrative_count = sum(1 for word in self.quality_standards["narrative_quality"] 
                                    if word in content.lower())
                if narrative_count < 1:
                    issues.append(f"{file_path.name}: Quest needs more story/lore hooks.")
            
            # Check 5: No generic fantasy clich√©s
            cliches = ["dark and stormy", "brave hero", "evil wizard", "chosen one"]
            for cliche in cliches:
                if cliche in content.lower():
                    issues.append(f"{file_path.name}: Contains clich√© '{cliche}'. Be more original.")
            
            # Check 6: Proper formatting
            if not content.strip():
                issues.append(f"{file_path.name}: File is empty.")
            
        except Exception as e:
            issues.append(f"{file_path.name}: Error reading file - {e}")
        
        return issues
    
    def _update_task_status(self, task_id, new_status):
        """Update task status in agent_tasks.json using parent class method."""
        # Use the parent class's safe _update_json method
        # which preserves all file structure
        try:
            import fcntl
            from pathlib import Path
            
            status_file = Path('agent_tasks.json')
            with open(status_file, 'r+') as f:
                fcntl.flock(f.fileno(), fcntl.LOCK_EX)
                
                data = json.load(f)
                
                for task in data.get('tasks', []):
                    if task['id'] == task_id:
                        task['status'] = new_status
                        task['updated_at'] = datetime.now().isoformat()
                        break
                
                f.seek(0)
                f.truncate()
                json.dump(data, f, indent=2)
                
        except Exception as e:
            self.log(f"Error updating task status: {e}")
    
    def can_answer(self, message):
        """Check if Code Reviewer can answer this question."""
        keywords = ['quality', 'review', 'standards', 'lore', 'sensory', 'discworld', 'clich√©', 'immersion']
        msg_text = message.get('message', '').lower()
        return any(k in msg_text for k in keywords)
    
    def generate_response(self, message):
        """Generate response to quality-related questions."""
        msg_text = message.get('message', '').lower()
        agent = message.get('agent', 'Unknown')
        
        # Quality standards question
        if 'quality' in msg_text or 'standards' in msg_text or 'discworld' in msg_text:
            return (
                f"@{agent} - For high-quality content, ensure:\n"
                "‚Ä¢ Sensory details (smells, sounds, textures)\n"
                "‚Ä¢ Atmospheric keywords (shadows, damp, weathered)\n"
                "‚Ä¢ Narrative hooks (story, mystery, legend)\n"
                "‚Ä¢ No clich√©s (avoid 'dark and stormy', 'chosen one')\n"
                "‚Ä¢ Minimum 200 characters"
            )
        
        # Sensory details question
        if 'sensory' in msg_text or 'details' in msg_text:
            return (
                f"@{agent} - Add sensory richness:\n"
                "‚Ä¢ Smell: musty, acrid, sweet, damp, rotting\n"
                "‚Ä¢ Sound: echo, whisper, clatter, creak, drip\n"
                "‚Ä¢ Touch: rough, smooth, cold, sticky, slimy\n"
                "‚Ä¢ Sight: flickering, gleaming, shadowed, dim"
            )
        
        # Lore/immersion question
        if 'lore' in msg_text or 'immersion' in msg_text:
            return (
                f"@{agent} - For immersive lore:\n"
                "‚Ä¢ Reference history/legends\n"
                "‚Ä¢ Use weathered/ancient descriptions\n"
                "‚Ä¢ Add mysterious elements\n"
                "‚Ä¢ Avoid modern language"
            )
        
        # Clich√© question
        if 'clich√©' in msg_text or 'avoid' in msg_text:
            return (
                f"@{agent} - Avoid these clich√©s:\n"
                "‚Ä¢ 'dark and stormy night'\n"
                "‚Ä¢ 'chosen one'\n"
                "‚Ä¢ 'ancient evil'\n"
                "‚Ä¢ 'mysterious stranger'\n"
                "Be specific and unique instead!"
            )
        
        # Help request
        if 'help' in msg_text or 'review' in msg_text:
            return f"@{agent} - I can review your work! Mark it as review_ready when done and I'll check it thoroughly."
        
        return None


if __name__ == "__main__":
    agent = CodeReviewerAgent()
    agent.run_loop()
