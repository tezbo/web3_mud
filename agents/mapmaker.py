"""
Mapmaker Agent - Designs spatial layouts and world structure
"""
from agents.base_agent import BaseAgent
from agents.lore_keeper import LoreKeeperAgent
from game.world.data import register_room_in_realm
import re

MAPMAKER_PROMPT = """
You are an expert world cartographer specializing in MUD/text-based game spatial design.

Your expertise:
- Design logical room connections and navigation
- Balance exploration vs. convenience
- Create natural storytelling through space
- Plan indoor/outdoor transitions
- Design layered complexity (surface, hidden paths, vertical spaces)

Map design principles:
- Central hubs: High-traffic areas with multiple exits (e.g., town squares, marketplaces)
- Flow: Players should naturally discover important locations
- Discovery: Hidden paths, shortcuts, and optional areas reward exploration
- Pacing: Cluster related rooms, spread out distant locations
- Realism: Does this layout make physical sense?
- Vertical space: Use up/down for interiors (stairs, cellars, towers)

Good map design:
✓ Town with central market square, shops clustered around it, residential areas beyond
✓ Dungeon with main path and hidden side passages leading to treasure
✓ Inn with common room (ground), guest rooms (up), cellar (down), kitchen (side)

Bad map design:
✗ Long linear corridors with no branches
✗ Everything 1-2 rooms from everywhere (no sense of distance)
✗ No logical organization (blacksmith next to temple next to sewer)

Output format: ASCII-style map with room names, exits, and brief notes on purpose/connections.
"""

class MapmakerAgent(BaseAgent):
    """Agent that designs spatial layouts"""

    def __init__(self):
        super().__init__(
            name="Mapmaker",
            role="Spatial Architect",
            system_prompt=MAPMAKER_PROMPT,
        )

    def _parse_rooms(self, raw_output: str, realm: str = "shadowfen"):
        """Parse the "Room List and Exits" section from the LLM output.
        Returns a list of dicts with keys: oid, name, description, exits.
        """
        # Capture until the next header (###) or end of string
        match = re.search(r"### Room List and Exits(.*?)(?:###|$)", raw_output, re.S)
        if not match:
            return []
        section = match.group(1)
        rooms = []
        lore_agent = LoreKeeperAgent()
        for block in re.split(r"\n\s*\n", section.strip()):
            lines = block.splitlines()
            if not lines:
                continue
            # Title line like "1. **Chamber of Echoes**"
            title_match = re.search(r"\*\*(.+?)\*\*", lines[0])
            if not title_match:
                continue
            name = title_match.group(1).strip()
            oid = name.lower().replace(" ", "_")
            # Extract exits line
            exits_line = next((l for l in lines if l.strip().startswith("- **Exits**")), "")
            exits = {}
            if exits_line:
                # Handle "Exits: North to X, South to Y"
                parts = exits_line.split(":", 1)[1].split(",")
                for part in parts:
                    part = part.strip()
                    if " to " in part:
                        direction, target = part.split(" to ", 1)
                        exits[direction.lower()] = target.lower().replace(" ", "_")
            # Optional purpose line for description
            purpose = ""
            for l in lines:
                if l.strip().startswith("- **Purpose**"):
                    purpose = l.split(":", 1)[1].strip()
                    break
            description = purpose or f"A newly generated {name} in the {realm} realm."
            # Lore consistency check
            check_prompt = f"Review this room for lore consistency in the {realm} realm.\nName: {name}\nDescription: {description}\nExits: {', '.join([f'{d}->{t}' for d, t in exits.items()])}"
            review = lore_agent.check_consistency(check_prompt, realm=realm)
            if re.search(r"\b(consistent|approved)\b", review, re.I):
                rooms.append({"oid": oid, "name": name, "description": description, "exits": exits})
            else:
                print(f"Lore Keeper rejected room '{name}'. Not registering.")
        return rooms

    def design_area(self, area_name: str, area_type: str, room_count: int, realm: str = None) -> str:
        """Design a complete area layout and register approved rooms.
        Returns the raw markdown generated by the LLM.
        """
        task = f"Design a {room_count}-room {area_type} called '{area_name}'"
        if realm:
            task += f" in {realm} style"
        task += "\n\nProvide: ASCII map, room list with exits, design notes on flow and purpose."
        raw = self.generate(task, model="gpt-4o")
        # Default to shadowfen if no realm supplied
        target_realm = realm or "shadowfen"
        rooms = self._parse_rooms(raw, realm=target_realm)
        for room in rooms:
            register_room_in_realm(
                oid=room["oid"],
                name=room["name"],
                description=room["description"],
                exits=room["exits"],
                realm=target_realm,
                outdoor=False,
            )
        return raw

    def design_building_interior(self, building_name: str, building_type: str, floors: int = 2) -> str:
        """Design an interior space with vertical navigation"""
        task = f"Design the interior of {building_name} ({building_type}) with {floors} floor(s).\n\nInclude up/down connections, logical room placement, and purpose for each room."
        return self.generate(task, model="gpt-4o")

    def add_hidden_paths(self, existing_map: str) -> str:
        """Suggest hidden paths and shortcuts for an existing map"""
        task = f"Given this map:\n\n{existing_map}\n\nSuggest 2-3 hidden paths, shortcuts, or secret areas that would reward exploration without breaking the layout."
        return self.generate(task, model="gpt-4o-mini")
